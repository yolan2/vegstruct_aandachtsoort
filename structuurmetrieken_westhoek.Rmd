---
title: "structuurmetrieken westhoek"
author: "Yolan Bosteels"
date: "2025-04-25"
output: html_document
---

```{r}
wd <- ("C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/R/")
setwd(wd)
```
############
STATISTIEKEN
############
#Inladen van packages
```{r}
library(raster)
library(vegan)
library(spdep)
library(ape)



#functie voor berekenen shannon roughness
sh <- function(x,...){
  x = table(na.omit(as.vector(x)))
  return(diversity(x, index = "shannon"))
}

library(spdep)

library(spdep)

moran_i <- function(x, ...) {
  valid_values <- na.omit(x)
  # als er meer dan 5 in het totaal aantal van 25 cellen NA zijn wordt er geen Morans I berekend
  if (length(valid_values) < 5) {
    return(NA)
  }
  
  cell_size <- sqrt(length(x))
  coords <- expand.grid(1:cell_size, 1:cell_size)
  coords <- coords[!is.na(x), ]
  nb <- dnearneigh(coords, 0, 1.1)#angrenzende cellen worden gedefinieerd als cellen waarvan het celcentrum op maximaal 1m ligt van het centrum van een cel. 
  
  
  degrees <- card(nb)
  
  # Filter to only nodes with non-zero degree
  nonzero_degrees <- sum(degrees > 0)
  
  # Check if we have at least 20 conneted nodes
  if (nonzero_degrees < 20) {
    return(NA)
  }
  
  wts_listw <- nb2listw(nb, style = "B", zero.policy = TRUE)  # <<< HERE: allow zero neighbors
  x_valid <- as.vector(valid_values)
  moran <- Moran.I(x_valid, w = listw2mat(wts_listw), na.rm = TRUE, scaled = TRUE)
  
  return(moran$observed)
}




```

INLADEN RASTERS
```{r}
crss = " +proj=lcc +lat_0=90 +lon_0=4.36748666666667 +lat_1=49.8333339 +lat_2=51.1666672333333 +x_0=150000.01256 +y_0=5400088.4378 +ellps=intl +units=m +no_defs  "

cell_size <- 5 #default celgroote voor dit project

chm_ras1 = raster('wh_vh1m.tif', crs = crss)
chm_ras1[chm_ras1 < 0] <- NA

chm_ras5 = aggregate(chm_ras1, fun = mean, fact = cell_size/res(chm_ras1))


classes_df = c(-Inf,1, 1,1,2,2,2,5,3,5,Inf,4)
classes_chm = matrix(classes_df,ncol = 3, byrow=T)
classes_df = c(-Inf, 0,1, 0, 0.25,2, 0.25,0.5,3, 0.5,0.75,4,0.75,1,5)


chm_clas5 = reclassify(chm_ras5, classes_chm)




```
als je gdrive nog niet geauthenticeerd is ga je hier vastlopen. Run dan even drive_auth() in je console en probeer opnieuw.

```{r}
tmp_begrazing <- tempfile(fileext = ".RData")
drive_download(
  as_id("14gUaFIpvGHy9dYht9vwvEbvPyUbxAQXl"),
  path      = tmp_begrazing,
  overwrite = TRUE
)
load(tmp_begrazing)
```


GRAZING DENSITY: Hier wordt de begrazingsdata geagregeerd tot op 25x25m. Een correcte filtering van deze data dient nog te gebeuren!!!

```{r}
library(terra)

# --- Load CHM raster ---
chm_ras1 <- rast('wh_vh1m.tif')
crs(chm_ras1) <- crss  # indien nog niet ingesteld
chm_ras1[chm_ras1 < 0] <- NA

# --- Aggregate to 25 m resolution ---
chm_ras25 <- aggregate(chm_ras1, fact = 25 / res(chm_ras1)[1], fun = "mean")

# --- Create raster template aligned with chm_ras25 ---
template_raster <- rast(ext(chm_ras25), resolution = 25, crs = crs(chm_ras25))


data_westhoek$x <- as.numeric(as.character(data_westhoek$x))
data_westhoek$y <- as.numeric(as.character(data_westhoek$y))

# Maak SpatVector
data_vect <- vect(data_westhoek, geom = c("x", "y"), crs = crss)

# --- Rasterize: count number of points per 25x25 m cell ---
grazing_density <- rasterize(data_vect, template_raster, fun = "count", background = 0)

# --- Fix any NA to 0 ---
grazing_density[is.na(grazing_density)] <- 0

# --- Plot result ---
plot(grazing_density, main = "Begrazingsdichtheid (25m raster)")
print(grazing_density)

```
```{r}
chm_matrix <- as.matrix(chm_ras1)
chm_ras1[chm_ras1>1.2] <- 1.2
# Apply Gaussian blur for noise reduction
apply_gaussian_blur <- function(mat, sigma = 1) {
  kernel_size <- 5
  gaussian_filter <- matrix(0, nrow = kernel_size, ncol = kernel_size)
  center <- (kernel_size + 1) / 2

  for (i in 1:kernel_size) {
    for (j in 1:kernel_size) {
      x <- i - center
      y <- j - center
      gaussian_filter[i, j] <- exp(-(x^2 + y^2) / (2 * sigma^2))
    }
  }

  gaussian_filter <- gaussian_filter / sum(gaussian_filter)

  # Apply Gaussian blur using terra::focal
  mat_blurred <- focal(mat, w = gaussian_filter, fun = sum, na.rm = TRUE)
  return(mat_blurred)
}

# Apply Gaussian blur
chm_blurred <- apply_gaussian_blur(chm_ras1)

# Calculate gradient magnitude (edgeness)
grad_x <- focal(chm_blurred, w = matrix(c(-1, 0, 1, -2, 0, 2, -1, 0, 1), 3, 3))
grad_y <- focal(chm_blurred, w = matrix(c(-1, -2, -1, 0, 0, 0, 1, 2, 1), 3, 3))
grad_magnitude <- sqrt(grad_x^2 + grad_y^2)

# Mask gradient to only focus on areas where CHM is below 0.5
chm_edges_filtered <- mask(grad_magnitude, chm_blurred < 1)

# Normalize the edges for better visualization
chm_edges_filtered <- (chm_edges_filtered - min(chm_edges_filtered[], na.rm = TRUE)) / (max(chm_edges_filtered[], na.rm = TRUE) - min(chm_edges_filtered[], na.rm = TRUE))

chm_edges_aggregated <- aggregate(chm_edges_filtered, fact = 5, fun = "mean", na.rm = FALSE)



# Save the filtered edge-detected raster

# Display result
blue_yellow_palette <- colorRampPalette(c("blue", "yellow"))

# Plotting with Blue to Yellow Color Scale
plot(chm_edges_filtered, 
     main = "Filtered CHM Gradient Edge Detection (Low to High)", 
     col = blue_yellow_palette(100))

plot(chm_ras5, 
     main = "CHM Raster (Low to High)", 
     col = blue_yellow_palette(100))

plot(chm_edges_aggregated, 
     main = "Aggregated CHM Gradient Edge Detection (Low to High)", 
     col = blue_yellow_palette(100))

writeRaster(chm_edges_aggregated, paste0(folder,'wh_vh1m_edges_aggregated.tif'), overwrite = TRUE)
writeRaster(chm_edges_filtered, paste0(folder,'wh_vh1m_edges_filtered.tif'), overwrite = TRUE)

```
```{r}
chm_matrix <- as.matrix(chm_ras1)

# Calculate gradient magnitude (edgeness) without Gaussian blur
grad_x <- focal(chm_ras1, w = matrix(c(-1, 0, 1, -2, 0, 2, -1, 0, 1), 3, 3))
grad_y <- focal(chm_ras1, w = matrix(c(-1, -2, -1, 0, 0, 0, 1, 2, 1), 3, 3))
grad_magnitude <- sqrt(grad_x^2 + grad_y^2)

# Mask gradient to only focus on areas where CHM is below 0.5
chm_edges_filtered <- mask(grad_magnitude, chm_ras1 < 0.5)

# Normalize the edges for better visualization
chm_edges_filtered <- (chm_edges_filtered - min(chm_edges_filtered[], na.rm = TRUE)) / (max(chm_edges_filtered[], na.rm = TRUE) - min(chm_edges_filtered[], na.rm = TRUE))


# Display result
plot(chm_edges_filtered, main = "Filtered CHM Gradient Edge Detection (No Blur)")
```

Wat "saaie" indices
```{r}
chm_mean_f = aggregate(chm_ras1, fun = "mean", fact =25)

chm_min_f = aggregate(chm_ras1, fun = min, fact = cell_size/res(chm_ras1))

chm_max_f = aggregate(chm_ras1, fun = max, fact = cell_size/res(chm_ras1))

```

ROUGHNESS
```{r}
#Verticale heterogeniteit via Variantie AGGREGATED 0.25x0.25
chm_var = aggregate(chm_ras1, fact = cell_size/res(chm_ras1), fun = sd, na.rm = T)

```

DISTRIBUTION
```{r}
#Verticale heterogeniteit via Variantie AGGREGATED 0.25x0.25
chm_fish = aggregate(chm_ras1, fact = cell_size/res(chm_ras1), fun = skewness, na.rm = T) 

```

MORAN: Horizontale heterogeniteit via Morans I MOVING WINDOW
#omdat morans I wat meer moeite heeft met NO data values gaan we hier wat minder streng zijn rond NA waardes toekennen. Daarom laden we terug het originele bestand in. (chm_ras1_moran). Ook zal de warning subgraphs verschijnen. Dit gebeurt voor 5 cellen in het raster. Concreet wil dat zeggen dat er één of meerdere cellen geisoleerd zijn geraakt en dus geen buren hebben. De grootste cluster verbonden cellen wordt behouden en wordt gebruikt voor morans i. 
```{r}
chm_ras1_moran = raster('wh_vh1m.tif', crs = crss)
chm_locm_ras = aggregate(chm_ras1_moran, fun = moran_i, fact = 10/res(chm_ras1))

```
```{r}
plot(chm_locm_ras)
```

SHANNON
```{r}
#Verticale heterogeniteit via Shannon
classes_df = c(-Inf,0.5, 1,0.5,2,3,2,Inf,3)
classes_chm = matrix(classes_df,ncol = 3, byrow=T)
chm_clas1 = reclassify(chm_ras1, classes_chm)
chm_H_class = aggregate(chm_clas1, fact = cell_size/res(chm_clas1), sh)
```



WRITE RASTERS
```{r}
folder = "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/hoogtemetrieken/"


writeRaster(chm_H_class, 
            filename = paste0(folder, "chm_shannon.tif"), 
            format = "GTiff", 
            overwrite = TRUE)

writeRaster(chm_mean_f, 
            filename = paste0(folder, "chm_mean25.tif"), 
            format = "GTiff", 
            overwrite = TRUE)
writeRaster(chm_ras5, 
            filename = paste0(folder, "chm_mean5.tif"), 
            format = "GTiff", 
            overwrite = TRUE)

writeRaster(chm_locm_ras, 
            filename = paste0(folder, "chm_localmoran.tif"), 
            format = "GTiff", 
            overwrite = TRUE)

writeRaster(chm_fish, 
            filename = paste0(folder, "chm_fisher.tif"), 
            format = "GTiff", 
            overwrite = TRUE)

writeRaster(chm_max_f, 
            filename = paste0(folder, "chm_max.tif"), 
            format = "GTiff", 
            overwrite = TRUE)

writeRaster(chm_min_f, 
            filename = paste0(folder, "chm_min.tif"), 
            format = "GTiff", 
            overwrite = TRUE)
writeRaster(count_raster, 
            filename = paste0(folder, "grazing_density.tif"), 
            format = "GTiff", 
            overwrite = TRUE)
```

Of als je slechts eentje wilt schrijven:
```{r}
folder = "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/hoogtemetrieken/"
writeRaster(
  grazing_density,
  filename = paste0(folder, "grazing_density.tif"),
  overwrite = TRUE
)

```

