---
title: "Model Vegetatiestructuur & Visualisatie"
output: html_document
---

```{r setup, include=FALSE}
# Global options
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)

# Required libraries
library(tidyverse)
library(terra)
library(INLA)
library(data.table)
library(spdep)
library(Matrix)
library(raster)
```

## Load Canopy Height Model (CHM) Metrics
```{r load_chm}
# Define input paths
input_folder <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/hoogtemetrieken/"
plot_dir     <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/R/aandachtsoorten_results/plots"

# Create plot directory if needed
if (!dir.exists(plot_dir)) dir.create(plot_dir, recursive = TRUE)

# Load CHM metrics as a named list
chm_metrics_25 <- list(
  #mean    = rast(file.path(input_folder, "chm_mean25.tif")),
  begrazing_maa = rast(file.path(input_folder, "grazing_diff_norm_month_03.tif")),
  begrazing_apr = rast(file.path(input_folder, "grazing_diff_norm_month_04.tif")),
  begrazing_mei = rast(file.path(input_folder, "grazing_diff_norm_month_05.tif")),
  begrazing_jun   = rast(file.path(input_folder, "grazing_diff_norm_month_06.tif")),
  begrazing_jul  = rast(file.path(input_folder, "grazing_diff_norm_month_07.tif")),
  begrazing_aug     = rast(file.path(input_folder, "grazing_diff_norm_month_08.tif")),
  begrazing_sep     = rast(file.path(input_folder, "grazing_diff_norm_month_09.tif")),
  begrazing = rast(file.path(input_folder, "grazing_density.tif"))
)

chm_metrics_5 <- list(
  #shannon = rast(file.path(input_folder, "chm_shannon.tif")),
  #mean    = rast(file.path(input_folder, "chm_ras5.tif")),
  #moran   = rast(file.path(input_folder, "chm_localmoran.tif")),
  #fisher  = rast(file.path(input_folder, "chm_fisher.tif")),
  #max     = rast(file.path(input_folder, "chm_max.tif")),
  #min     = rast(file.path(input_folder, "chm_min.tif")),
  edgness_glow = rast(file.path(input_folder, "wh_vh1m_edges_glow.tif")),
  #edgness_avg = rast(file.path(input_folder, "wh_vh1m_edges_aggregated.tif")),
  edgness_2 = rast(file.path(input_folder, "wh_vh1m_edges_filtered.tif"))
)

crss = " +proj=lcc +lat_0=90 +lon_0=4.36748666666667 +lat_1=49.8333339 +lat_2=51.1666672333333 +x_0=150000.01256 +y_0=5400088.4378 +ellps=intl +units=m +no_defs  "

cell_size <- 5 #default celgroote voor dit project

chm_ras1 = raster('wh_vh1m.tif', crs = crss)
chm_ras1[chm_ras1 < 0] <- NA
chm_ras1[chm_ras1 > 1.5] <- NA

chm_ras5 = aggregate(chm_ras1, fun = "mean", fact = cell_size/res(chm_ras1))
```

```{r}
# Calculate correlations between all CHM metrics
calculate_chm_correlations <- function(chm_metrics) {
  message("Calculating correlations between CHM metrics")

  # Stack all CHM metrics into a single raster stack
  chm_stack <- rast(chm_metrics)

  # Extract values as a dataframe
  chm_df <- as.data.frame(terra::values(chm_stack, na.rm = TRUE))
  colnames(chm_df) <- names(chm_metrics)

  # Remove any rows with NA values
  chm_df <- chm_df[complete.cases(chm_df),]

  # Calculate correlation matrix
  cor_matrix <- cor(chm_df, method = "pearson")

  return(cor_matrix)
}


cor_matrix <- calculate_chm_correlations(chm_metrics_5)
print(cor_matrix)
```
```{r}


```


## Functions: Process & Model per Species: doet enkel analyses van resolutie 25m
```{r functions}
analyze_species_25 <- function(path, chm_metrics) {
  species_name <- gsub("_combined.tif", "", basename(path), fixed = TRUE)
  message("Processing: ", species_name)

  # --- read & aggregate to 25m
  ras <- rast(path)
  ras <- aggregate(ras, fun = "sum", fact = 5)
  crs(ras) <- crss

  # --- mask & build binaries
  ras[ras < 0.5] <- 0
  bin_ras <- ifel(ras > 0, 1, NA)    # NA beyond any non-zero
  ras_bin <- ifel(ras > 0.5, 1, 0)   # 0/1 presence

  results25 <- list()

  for (m in names(chm_metrics)) {
    message("  Metric: ", m)
    chm <- chm_metrics[[m]]

    # quick peek
    # plot(chm)
    # plot(ras * 100, main = paste("Species:", species_name))

    # --- stack & extract
    stk <- c(chm, ras_bin, ras)
    names(stk) <- c("chm", "species_binary", "species")
    vals  <- terra::values(stk, dataframe = TRUE, na.rm = TRUE)
    cells <- which(!is.na(vals$chm))
    coords_df <- terra::xyFromCell(stk, cells)
    df    <- as.data.table(cbind(coords_df, vals[cells, ]))

    if (nrow(df)==0 || sum(df$species_binary)==0) next
    if (sum(df$species > 1) < 20) {
      warning("  <20 overlapping values — skipping.")
      next
    }

    message("  Calculating neighborhood structure")
    # --- compute neighbours!
    coords_mat <- as.matrix(df[, .(x,y)])
    nb         <- knearneigh(coords_mat, k = 4) |>
                  knn2nb(sym = TRUE)
    W          <- as(nb2mat(nb, style = "B"), "sparseMatrix")
    diag(W)    <- 0

    if (nrow(W) != nrow(df)) {
      warning("  Neighbour matrix size mismatch — skipping.")
      next
    }

    message("  Creating INLA graph & fitting models")
    df[, spatial_id := .I]
    g <- inla.read.graph(W)

    # binary
    mb <- inla(
      species_binary ~ chm + f(spatial_id, model="besag", graph=g),
      data = df, family = "binomial",
      control.compute = list(dic=TRUE, waic=TRUE)
    )

    # positive
    dfp <- df[species > 0]
    mp  <- NULL
    if (nrow(dfp)>0) {
      mp <- inla(
        species ~ chm + f(spatial_id, model="besag", graph=g),
        data = dfp, family = "gamma",
        control.compute = list(dic=TRUE, waic=TRUE)
      )
    }

    results25[[m]] <- list(
      binary_model   = mb,
      positive_model = mp
    )
  }

  return(results25)
}


```

TER INFO: OP 5m resolutie is er wel veel data. Hoge kans dat je computer vastloopt.

analyses van resolutie 5m
```{r}
library(terra)
library(data.table)
library(MASS)     # for boxcox()
library(INLA)

analyze_species_5 <- function(path, chm_metrics) {
  species_name <- gsub("_combined.tif$", "", basename(path))
  message("Processing: ", species_name)

  ras <- rast(path)
  ras[ras < 0.5] <- 0
  crs(ras) <- crss

  # Mask distant zeros
  bin_ras <- ifel(ras > 0.5, 1, NA)
  d0       <- distance(bin_ras)
  ras[d0 >= 0 & ras == 0] <- NA
  ras_bin  <- ifel(ras > 0.5, 1, 0)

  results <- list()

  # Loop over CHM metrics
  for (m in names(chm_metrics)) {
    message("  Metric: ", m)
    chm <- chm_metrics[[m]]

    # Stack and clean
    stk   <- c(chm, ras_bin, ras)
    names(stk) <- c("chm", "species_binary", "species")
    vals  <- terra::values(stk, dataframe = TRUE, na.rm = TRUE)
    ok    <- which(!is.na(vals$chm))
    df    <- as.data.table(cbind(terra::xyFromCell(stk, ok), vals[ok, ]))

    if (nrow(df) == 0 || sum(df$species_binary) == 0) next
    if (sum(df$species > 1 & df$chm > 0) < 20) {
      warning("Less than 20 overlapping values — skipping metric.")
      next
    }

    # Neighborhood structure
    coords <- as.matrix(df[, .(x,y)])
    nb     <- knearneigh(coords, k = 4) |> knn2nb(sym = TRUE)
    W      <- as(nb2mat(nb, style = "B"), "sparseMatrix")
    diag(W) <- 0
    if (nrow(W) != nrow(df)) next

    df[, spatial_id := .I]
    g <- inla.read.graph(W)

    # Fitting binary model
    mb <- inla(
      species_binary ~ chm + f(spatial_id, model = "besag", graph = g),
      data            = df,
      family          = "binomial",
      control.compute = list(dic = TRUE, waic = TRUE)
    )

    # Fitting positive (Box–Cox Gaussian) model
    dfp <- df[species > 0]
    mp  <- NULL
    if (nrow(dfp) > 0) {
      # histogram
      hist(dfp$species,
           breaks = 30,
           main   = paste("Positive values —", species_name, m),
           xlab   = "Abundance", ylab = "Frequency")

      # Box–Cox transform
      sp_df <- data.frame(y = dfp$species)
      bc    <- boxcox(y ~ 1, data = sp_df, plotit = FALSE)
      lambda <- bc$x[which.max(bc$y)]
      if (abs(lambda) < 1e-6) {
        dfp[, species_tr := log(species)]
      } else {
        dfp[, species_tr := (species^lambda - 1) / lambda]
      }
      message(sprintf("    Box–Cox λ = %.3f", lambda))

      # Fit Gaussian on transformed response
      mp <- inla(
        species_tr ~ chm + f(spatial_id, model = "besag", graph = g),
        data            = dfp,
        family          = "gaussian",
        control.family  = list(link = "identity"),
        control.compute = list(dic = TRUE, waic = TRUE)
      )

      # Residuals vs fitted
      fitted_vals <- mp$summary.fitted.values$mean
      resid_vals  <- dfp$species_tr - fitted_vals
      plot(fitted_vals, resid_vals,
           xlab = "Fitted (transformed)",
           ylab = "Residuals (transformed)",
           main = paste("Residuals vs Fitted (Box–Cox)\n", species_name, m))
      abline(h = 0, lty = 2)
    }

    results[[m]] <- list(
      binary_model   = mb,
      positive_model = mp
    )
  }

  return(results)
}

```


Hier testen we of een lineaire of exponentiele regressie het best werkt. 
```{r}

library(terra)
library(data.table)
library(MASS)     # for boxcox()
library(INLA)

analyze_species_test <- function(path, chm_metrics) {
  species_name <- sub("_combined\\.tif$", "", basename(path))
  message("Processing: ", species_name)

  # --- 1) raster prep ---
  ras <- rast(path)
  ras[ras < 0.5] <- 0
  crs(ras) <- crss
  bin_ras <- ifel(ras > 0.5, 1, NA)
  d0      <- distance(bin_ras)
  ras[d0 >= 0 & ras == 0] <- NA
  ras_bin <- ifel(ras > 0.5, 1, 0)

  results <- list()

  # --- 2) loop over CHM metrics ---
  for (m in names(chm_metrics)) {
    message("  Metric: ", m)
    chm <- chm_metrics[[m]]

    # stack & extract values
    stk   <- c(chm, ras_bin, ras)
    names(stk) <- c("chm", "species_binary", "species")
    vals  <- terra::values(stk, dataframe = TRUE, na.rm = TRUE)
    ok    <- which(!is.na(vals$chm))
    df    <- data.table(
               terra::xyFromCell(stk, ok),
               vals[ok, ]
             )

    # skip if no data or no presences
    if (nrow(df) == 0 || sum(df$species_binary) == 0) {
      warning("    no data or presences → skipping")
      next
    }
    if (sum(df$species > 1 & df$chm > 0) < 20) {
      warning("    <20 overlapping pts → skipping")
      next
    }

    # build neighborhood structure & INLA graph
    nb      <- knearneigh(as.matrix(df[, .(x,y)]), k = 4) |>
               knn2nb(sym = TRUE)
    W       <- as(nb2mat(nb, style = "B"), "sparseMatrix")
    diag(W) <- 0
    if (nrow(W) != nrow(df)) {
      warning("    neighbour matrix mismatch → skipping")
      next
    }
    df[, spatial_id := .I]
    g <- inla.read.graph(W)

    # 3) binary model
    mb <- inla(
      species_binary ~ chm + f(spatial_id, model = "besag", graph = g),
      data            = df,
      family          = "binomial",
      control.compute = list(dic = TRUE, waic = TRUE)
    )

    # 4) positive‐abundance block
    dfp <- df[species > 0]
    pos_res <- list(boxcox = NULL, gamma = NULL, best = NA)

    if (nrow(dfp) > 0) {
      # A) prepare simple df for Box–Cox
      sp_df <- data.frame(y = dfp$species)

      # B) find optimal λ
      bc     <- boxcox(y ~ 1, data = sp_df, plotit = FALSE)
      lambda <- bc$x[which.max(bc$y)]

      # C) transform in-place
      if (abs(lambda) < 1e-6) {
        dfp[, species_tr := log(species)]
      } else {
        dfp[, species_tr := (species^lambda - 1) / lambda]
      }

      # D) fit Box–Cox + Gaussian
      mp_bc <- inla(
        species_tr ~ chm + f(spatial_id, model = "besag", graph = g),
        data            = dfp,
        family          = "gaussian",
        control.family  = list(link = "identity"),
        control.compute = list(dic = TRUE, waic = TRUE)
      )
      dic_bc <- mp_bc$dic$dic

      # E) fit Gamma + log link
      mp_gam <- inla(
        species ~ chm + f(spatial_id, model = "besag", graph = g),
        data            = dfp,
        family          = "gamma",
        control.compute = list(dic = TRUE, waic = TRUE)
      )
      dic_gam <- mp_gam$dic$dic

      # F) compare DICs
      best <- if (dic_bc < dic_gam) "Box–Cox Gaussian" else "Gamma-log"
      message(sprintf("    DIC → Box–Cox=%.1f, Gamma=%.1f → best: %s",
                      dic_bc, dic_gam, best))

      pos_res <- list(
        boxcox = list(model = mp_bc, dic = dic_bc, lambda = lambda),
        gamma  = list(model = mp_gam, dic = dic_gam),
        best   = best
      )
    } else {
      message("    no positive values → skipping positive block")
    }

    results[[m]] <- list(
      binary_model    = mb,
      positive_models = pos_res
    )
  }

  return(results)
}

process_all_species <- function(dir, chm_metrics) {
  tif_files <- list.files(dir, pattern = "_combined\\.tif$", full.names = TRUE)
  out <- vector("list", length(tif_files))
  names(out) <- basename(tif_files)

  for (f in tif_files) {
    gc()
    out[[basename(f)]] <- analyze_species_5(f, chm_metrics)
  }

  return(out)
}

# Example usage:
all_results_test <- process_all_species(species_folder, chm_metrics_5)










```



```{r}
# pull out all the “best” strings
best_list <- unlist(lapply(all_results_test, function(sp) {
  sapply(sp, function(m) m$positive_models$best)
}))

# drop any NA (cases with no positives)
best_list <- best_list[!is.na(best_list)]

# tabulate
best_counts <- table(best_list)
print(best_counts)

```



Hier kan je het model eindelijk runnen. Dit is echter het zwaarste stuk van heel het project. Doe dit dus niet zomaar! Om tijd te besparen kan je de test data (alternatieve species_folder) gebruiken. Hier gebruik je dan een subset van de data.

Merk op: Je dient nog te selecteren of je het model wil runnen voor de 5m resolutie parameters of 25m resolutie parameters (eg. begrazing). En dat op twee plaatsen, zie comments. 

Zorg dat je geen bestanden geopend hebt die INLA gebruikt (bijvoorbeeld de rasters). Anders crasht het programma.



```{r process_all, message=TRUE, warning=TRUE}
# Apply analyze_species across all TIFF files
chm_metrics <- chm_metrics_25 #kies 5 (m) of 25  (m) resolutie

process_all_species <- function(dir, chm_metrics) {
  all <- list.files(dir, full.names = TRUE)
  tif <- all[endsWith(all, "_combined.tif")]
  out <- list()
  for (f in tif) {
    out[[basename(f)]] <- analyze_species_25(f, chm_metrics)#kies opnieuw 5 (m) of 25  (m) resolutie
    gc()
  }
  return(out)
}

# Run modeling
species_folder <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/R/aandachtsoorten/"
#species_folder <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/R/aandachtsoorten_test/"
all_results5 <- process_all_species(species_folder, chm_metrics)
```

Hier gaan we de namen veranderen naar nederlandse namen. Kies ook opnieuw of je met de resultaten van 5m of 25m resolutie werkt.

```{r}
all_results <- all_results5
tmp_lookup <- tempfile(fileext = ".xlsx")

# download the Google Sheet as xlsx
drive_download(
  as_id("1-hlCyqBvBbhOLiPWDGNZPa20i8dRq0yr"),  # your sheet’s file ID
  path      = tmp_lookup,
  type      = "xlsx",
  overwrite = TRUE
)

# read the “soorten” sheet (you can also use sheet = 2 if you prefer index)
lookup_table <- read_excel(tmp_lookup, sheet = "Soorten")
# 2. Prepare the lookup map: names = CODE, values = NEDERLANDSENAAMLEN
name_map <- setNames(lookup_table$NEDERLANDSENAAMLEN,
                     lookup_table$CODE)

# 3. Clean and remap all_results names
#    a) strip “_combined.tif”
clean_sp <- sub("_combined\\.tif$", "", names(all_results))

#    b) map to Dutch names when CODE matches, otherwise keep cleaned code
new_sp <- ifelse(
  clean_sp %in% names(name_map),
  name_map[clean_sp],
  clean_sp
)

# 4. Assign the new names back
names(all_results) <- new_sp
species_names <- names(all_results)
```




## Visualization of positive data
```{r run_all}
library(dplyr)
library(ggplot2)
library(tibble)

# Function to plot and save the gamma model
plot_gamma_model <- function(sp, mn, model, plot_dir) {
  cat("✅ Plotting model for:", sp, mn, "\n")
  
  # Extract model coefficients
  b0   <- model$summary.fixed["(Intercept)", "mean"]
  b1   <- model$summary.fixed[2, "mean"]
  prec <- model$summary.hyperpar[1, "mean"]
  
  # Create prediction grid
  grid <- seq(0, 10, length.out = 100)
  linp <- b0 + b1 * grid
  mp   <- exp(linp)
  lo   <- qgamma(0.05, shape = prec, scale = mp / prec)
  hi   <- qgamma(0.95, shape = prec, scale = mp / prec)
  pd   <- tibble(x = grid, fit = mp, lower = lo, upper = hi)
  
  # p-value for slope
  est <- b1
  se  <- model$summary.fixed[2, "sd"]
  pval <- 2 * (1 - pnorm(abs(est / se)))
  
  cat("✅ Model coefficients: Intercept =", b0,
      "| Slope =", b1,
      "| Precision =", prec, "\n")
  cat("✅ Plotting model with p-value:",
      format.pval(pval, digits = 3), "for", sp, mn, "\n")
  
  # Build the ggplot, including species name in the title
  p2 <- ggplot(pd, aes(x = x, y = fit)) +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    geom_line() +
    labs(
      title    = paste0("Species: ", sp),
      subtitle = paste0("Model: ", mn, " (p = ", format.pval(pval, digits = 2), ")"),
      x        = "Predictor (Grid)",
      y        = "Abundance"
    ) +
    theme_minimal()
  
  # Save the plot
  output_path <- file.path(plot_dir, paste0(sp, "_", mn, "_gamma.png"))
  cat("✅ Saving plot at:", output_path, "\n")
  
  tryCatch({
    ggsave(output_path, p2, width = 8, height = 6, dpi = 300)
    cat("✅ Plot saved successfully\n")
  }, error = function(e) {
    cat("❌ Error saving plot:", e$message, "\n")
  })
}

# Main Loop: Processing all species and all models
for (sp in names(all_results)) {
  res <- all_results[[sp]]  # res is a list of models per metric
  
  cat("\nProcessing species:", sp, "\n")
  
  for (mn in names(res)) {
    mr <- res[[mn]]
    
    # Skip if no positive model
    if (is.null(mr$positive_model)) {
      cat("❌ Skipping", mn, "- No positive model\n")
      next
    }
    
    cat("✅ Processing model:", mn, "\n")
    
    # Extract the model
    model <- mr$positive_model
    
    # Plot and save
    plot_gamma_model(sp, mn, model, plot_dir)
  }
}



```

```{r}
  saveRDS(
    res,
    file = file.path(plot_dir, paste0(sp, "_all_metrics_res.rds"))
  )
```
Results of binary data. 
```{r}
library(dplyr)
library(tibble)
library(purrr)
library(knitr)

binary_sig_summary_all <- 
  # 1) iterate over your species_names vector
  map_dfr(species_names, function(sp) {
    # 2) get that species’ results
    res <- all_results[[sp]]
    if (is.null(res)) return(NULL)
    
    # 3) for each metric in that species
    imap_dfr(res, function(mr, mn) {
      bm <- mr$binary_model
      if (is.null(bm)) return(NULL)
      
      # 4) extract and tidy the fixed‐effects summary
      as.data.frame(bm$summary.fixed) %>%
        rownames_to_column("Predictor") %>%
        rename(
          mean    = mean,
          sd      = sd,
          lower90 = `0.025quant`,
          upper90 = `0.975quant`
        ) %>%
        mutate(
          Species = sp,
          Metric  = mn,
          # two‐sided p‐value
          p.value = 2 * (1 - pnorm(abs(mean / sd)))
        ) %>%
        select(Species, Metric, Predictor, mean, sd, p.value, lower90, upper90)
    })
  })

# 5) Print the results
if (nrow(binary_sig_summary_all) > 0) {
  kable(
    binary_sig_summary_all,
    caption = "Binary‐Model Fixed Effects (with p-values)"
  )
} else {
  cat("No binary‐model predictors found across any species.\n")
}


```

```{r}
df_results <- as.data.frame(binary_sig_summary_all)

# inspect
print(head(df_results))

csv_file <- file.path(plot_dir, "binary_sig_summary_all.csv")
write.csv2(df_results, csv_file, row.names = FALSE)
cat("Written:", csv_file, "\n")
```
Hier combineren we het logistische (binaire) model en het gaussiaanse model. We nemen als het ware de som van de twee modellen.


```{r}
library(dplyr)
library(purrr)
library(knitr)

# 0) Helper to extract summary.fixed as a named tibble:
get_fixed <- function(model) {
  as.data.frame(model$summary.fixed) %>%
    rownames_to_column("Predictor") %>%
    rename(
      mean = mean,
      sd   = sd
    ) %>%
    # drop intercept here so it never appears
    filter(Predictor != "(Intercept)")
}

# 1) Compute and store combined effects for each predictor
all_results <- map(all_results, function(res_sp) {
  map(res_sp, function(mr) {
    bm <- mr$binary_model
    gm <- mr$positive_model
    if (!is.null(bm) && !is.null(gm)) {
      fb <- get_fixed(bm)
      fg <- get_fixed(gm)
      # inner join on Predictor to keep only those in both models
      fb %>%
        inner_join(fg, by = "Predictor", suffix = c(".bin", ".gam")) %>%
        transmute(
          Predictor,
          mean  = mean.bin + mean.gam,
          sd    = sqrt(sd.bin^2 + sd.gam^2),
          pval  = 2 * (1 - pnorm(abs((mean.bin + mean.gam) / sd)))
        ) -> ce_tbl
      
      # store as list of lists
      mr$combined_effect <- ce_tbl
    }
    mr
  })
})

# 2) Build a long summary tibble
combined_summary <- map_dfr(
  names(all_results),
  function(sp) {
    map_dfr(
      names(all_results[[sp]]),
      function(mn) {
        ce <- all_results[[sp]][[mn]]$combined_effect
        if (is.null(ce) || nrow(ce) == 0) return(NULL)
        ce %>%
          mutate(Species = sp, Metric = mn) %>%
          select(Species, Metric, Predictor, mean, sd, pval)
      }
    )
  }
)

# 3) Print
if (nrow(combined_summary) > 0) {
  kable(
    combined_summary,
    caption = "Combined (Logistic+Positive) Effects per Predictor (Intercept Excluded)"
  )
} else {
  cat("No common predictors found in both models for any species/metric.\n")
}


```


```{r}
df_results <- as.data.frame(combined_summary)

# inspect
print(head(df_results))

csv_file <- file.path(plot_dir, "combined_summary_all.csv")
write.csv2(df_results, csv_file, row.names = FALSE)
cat("Written:", csv_file, "\n")
```

```{r}
library(dplyr)
library(tibble)
library(purrr)
library(knitr)

# — 1) assume you have these three data.frames already:
#    binary_sig_summary_all  (from your first chunk)
#    positive_sig_summary_all  (see below)
#    combined_summary        (from your second chunk)

# If you haven’t yet made the positive effects summary, here’s one way:
positive_sig_summary_all <-
  map_dfr(species_names, function(sp) {
    res <- all_results[[sp]]
    if (is.null(res)) return(NULL)

    imap_dfr(res, function(mr, mn) {
      gm <- mr$positive_model
      if (is.null(gm)) return(NULL)

      as.data.frame(gm$summary.fixed) %>%
        rownames_to_column("Predictor") %>%
        rename(
          pos_mean    = mean,
          pos_sd      = sd,
          pos_lower90 = `0.025quant`,
          pos_upper90 = `0.975quant`
        ) %>%
        mutate(
          Species = sp,
          Metric  = mn,
          pos_p.value = 2 * (1 - pnorm(abs(pos_mean / pos_sd)))
        ) %>%
        select(Species, Metric, Predictor, pos_mean, pos_sd, pos_p.value, pos_lower90, pos_upper90)
    })
  })

# — 2) Pull in your binary summary and combined summary, renaming columns to avoid clashes
bin  <- binary_sig_summary_all %>%
  rename(
    bin_mean    = mean,
    bin_sd      = sd,
    bin_p.value = p.value,
    bin_lower90 = lower90,
    bin_upper90 = upper90
  )

comb <- combined_summary %>%
  rename(
    comb_mean = mean,
    comb_sd   = sd,
    comb_pval = pval
  )

# — 3) Full-join all three on Species, Metric & Predictor
full_summary <- bin %>%
  full_join(positive_sig_summary_all, by = c("Species","Metric","Predictor")) %>%
  full_join(comb,                     by = c("Species","Metric","Predictor")) %>%
  # optional: order nicely
  arrange(Species, Metric, Predictor)

# — 4) Print and export
kable(full_summary,
      caption = "Binary, Positive and Combined Effects per Predictor") 

# write to CSV (using semicolon as separator)
csv_file <- file.path(plot_dir, "all_effects_summary.csv")
write.csv2(full_summary, csv_file, row.names = FALSE)
cat("Written:", csv_file, "\n")

```

