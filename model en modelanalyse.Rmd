---
title: "Model Vegetatiestructuur & Visualisatie"
output: html_document
---

```{r setup, include=FALSE}
# Global options
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)

# Required libraries
library(tidyverse)
library(terra)
library(INLA)
library(data.table)
library(spdep)
library(Matrix)
library(raster)
```

## Load Canopy Height Model (CHM) Metrics
```{r load_chm}
# Define input paths
input_folder <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/hoogtemetrieken/"
plot_dir     <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/R/aandachtsoorten_results/plots"

# Create plot directory if needed
if (!dir.exists(plot_dir)) dir.create(plot_dir, recursive = TRUE)

# Load CHM metrics as a named list
chm_metrics_25 <- list(
  #shannon = rast(file.path(input_folder, "chm_shannon.tif")),
  mean    = rast(file.path(input_folder, "chm_mean25.tif")),
  #moran   = rast(file.path(input_folder, "chm_localmoran.tif")),
  #fisher  = rast(file.path(input_folder, "chm_fisher.tif")),
  #max     = rast(file.path(input_folder, "chm_max.tif")),
  #min     = rast(file.path(input_folder, "chm_min.tif")),
  begrazing = rast(file.path(input_folder, "grazing_density.tif"))
)

chm_metrics_5 <- list(
  #shannon = rast(file.path(input_folder, "chm_shannon.tif")),
  mean    = rast(file.path(input_folder, "chm_ras5.tif")),
  #moran   = rast(file.path(input_folder, "chm_localmoran.tif")),
  #fisher  = rast(file.path(input_folder, "chm_fisher.tif")),
  #max     = rast(file.path(input_folder, "chm_max.tif")),
  #min     = rast(file.path(input_folder, "chm_min.tif")),
  #edgness_quant = rast(file.path(input_folder, "wh_vh1m_edges_quantile.tif")),
  #edgness_avg = rast(file.path(input_folder, "wh_vh1m_edges_aggregated.tif")),
  edgness_2 = rast(file.path(input_folder, "wh_vh1m_edges_filtered.tif"))
)

crss = " +proj=lcc +lat_0=90 +lon_0=4.36748666666667 +lat_1=49.8333339 +lat_2=51.1666672333333 +x_0=150000.01256 +y_0=5400088.4378 +ellps=intl +units=m +no_defs  "

cell_size <- 5 #default celgroote voor dit project

chm_ras1 = raster('wh_vh1m.tif', crs = crss)
chm_ras1[chm_ras1 < 0] <- NA
chm_ras1[chm_ras1 > 1.5] <- NA

chm_ras5 = aggregate(chm_ras1, fun = "mean", fact = cell_size/res(chm_ras1))
```

```{r}
# Calculate correlations between all CHM metrics
calculate_chm_correlations <- function(chm_metrics) {
  message("Calculating correlations between CHM metrics")

  # Stack all CHM metrics into a single raster stack
  chm_stack <- rast(chm_metrics)

  # Extract values as a dataframe
  chm_df <- as.data.frame(terra::values(chm_stack, na.rm = TRUE))
  colnames(chm_df) <- names(chm_metrics)

  # Remove any rows with NA values
  chm_df <- chm_df[complete.cases(chm_df),]

  # Calculate correlation matrix
  cor_matrix <- cor(chm_df, method = "pearson")

  return(cor_matrix)
}


cor_matrix <- calculate_chm_correlations(chm_metrics_5)
print(cor_matrix)
```


## Functions: Process & Model per Species: doet enkel analyses van resolutie 25m
```{r functions}
# Analyze one species: compute metrics and fit binary & positive models
analyze_species_25 <- function(path, chm_metrics) {
  species_name <- gsub("_combined.tif", "", basename(path), fixed = TRUE)
  message("Processing: ", species_name)

  ras <- rast(path)
  ras <- aggregate(ras, fun = "mean", fact = 5)
  crs(ras) <- crss
  ras[ras < 0.5] <- 0

  # Mask distant zeros
  bin_ras <- ifel(ras > 0, 1, NA)
  d0 <- distance(bin_ras)
  ras[d0 >= 70 & ras == 0] <- NA
  ras_bin <- ifel(ras > 1, 1, 0)

  results <- list()

  # Loop over CHM metrics
  for (m in names(chm_metrics)) {
    message("  Metric: ", m)

    chm <- chm_metrics[[m]]
    plot(ras * 100, main = paste("Species:", species_name))

    # Stack and clean
    message("Stacking and cleaning rasters")
    stk <- c(chm, ras_bin, ras)
    names(stk) <- c("chm", "species_binary", "species")
    vals <- terra::values(stk, dataframe = TRUE, na.rm = TRUE)
    coords <- terra::xyFromCell(stk, which(!is.na(vals[[1]])))
    df <- as.data.table(cbind(coords, vals))

    if (nrow(df) == 0 || sum(df$species_binary) == 0) next

    if (sum(df$species > 1 & df$chm > 0) < 20) {
      warning("Less than 20 overlapping values between species and CHM — skipping species.")
      next
    }

    message("Calculating neighborhood structure")

    coords <- as.matrix(df[, .(x, y)])
    k <- 4
    repeat {
      nb <- knearneigh(coords, k = k) |> knn2nb(sym = TRUE)
      if (all(card(nb) > 0) || k > 16) break
      k <- k + 4
    }

    if (k > 16) next

    W <- as(nb2mat(nb, style = "B"), "sparseMatrix")
    diag(W) <- 0

    if (nrow(W) != nrow(df)) next

    message("Creating INLA graph")
    df[, spatial_id := .I]
    g <- inla.read.graph(W)

    message("Fitting binary model")
    mb <- inla(
      species_binary ~ chm + f(spatial_id, model = "besag", graph = g),
      data = df, family = "binomial",
      control.compute = list(dic = TRUE, waic = TRUE)
    )

    message("Fitting positive model")
    dfp <- df[species > 0]
    mp <- NULL
    if (nrow(dfp) > 0) {
      mp <- inla(
        species ~ chm + f(spatial_id, model = "besag", graph = g),
        data = dfp, family = "gamma",
        control.compute = list(dic = TRUE, waic = TRUE)
      )
    }

    results[[m]] <- list(binary_model = mb, positive_model = mp)
  }

  # Full Model with all CHM metrics (outside loop)
  message("Fitting full model with all CHM metrics")
  full_stk <- rast(chm_metrics)
  full_stk <- c(full_stk, ras_bin, ras)
  names(full_stk) <- c(names(chm_metrics), "species_binary", "species")

  full_vals <- terra::values(full_stk, dataframe = TRUE, na.rm = TRUE)
  full_df <- as.data.table(full_vals)

  chm_formula <- paste(names(chm_metrics), collapse = " + ")

  mb_full <- inla(
    as.formula(paste("species_binary ~", chm_formula)),
    data = full_df, 
    family = "binomial",
    control.compute = list(dic = TRUE, waic = TRUE)
  )

  dfp_full <- full_df[species > 0]
  mp_full <- NULL
  if (nrow(dfp_full) > 0) {
    mp_full <- inla(
      as.formula(paste("species ~", chm_formula)),
      data = dfp_full, 
      family = "gamma",
      control.compute = list(dic = TRUE, waic = TRUE)
    )
  }

  results$full_model <- list(binary_model_full = mb_full, positive_model_full = mp_full)

  return(results)
}

```

TER INFO: OP 5m resolutie is er wel veel data. Hoge kans dat je computer vastloopt.

analyses van resolutie 5m
```{r}
# Analyze one species: compute metrics and fit binary & positive models
analyze_species_5 <- function(path, chm_metrics) {
  species_name <- gsub("_combined.tif", "", basename(path), fixed = TRUE)
  message("Processing: ", species_name)

  ras <- rast(path)
  ras[ras < 0.5] <- 0
  crs(ras) <- crss

  # Mask distant zeros
  bin_ras <- ifel(ras > 0.5, 1, NA)
  d0 <- distance(bin_ras)
  ras[d0 >= 0 & ras == 0] <- NA
  ras_bin <- ifel(ras > 1, 1, 0)

  results <- list()

  # Loop over CHM metrics
  for (m in names(chm_metrics)) {
    message("  Metric: ", m)

    chm <- chm_metrics[[m]]
    print(chm)
    print(ras_bin)

    # Stack and clean
    message("Stacking and cleaning rasters")
    stk <- c(chm, ras_bin, ras)
    names(stk) <- c("chm", "species_binary", "species")
    vals <- terra::values(stk, dataframe = TRUE, na.rm = TRUE)
    coords <- terra::xyFromCell(stk, which(!is.na(vals[[1]])))
    df <- as.data.table(cbind(coords, vals))

    if (nrow(df) == 0 || sum(df$species_binary) == 0) next

    if (sum(df$species > 1 & df$chm > 0) < 20) {
      warning("Less than 20 overlapping values between species and CHM — skipping species.")
      next
    }

    message("Calculating neighborhood structure")

    coords <- as.matrix(df[, .(x, y)])
    k <- 4
    nb <- knearneigh(coords, k = k) |> knn2nb(sym = TRUE)

    W <- as(nb2mat(nb, style = "B"), "sparseMatrix")
    diag(W) <- 0

    if (nrow(W) != nrow(df)) next

    message("Creating INLA graph")
    df[, spatial_id := .I]
    g <- inla.read.graph(W)

    message("Fitting binary model")
    mb <- inla(
      species_binary ~ chm + f(spatial_id, model = "besag", graph = g),
      data = df, family = "binomial",
      control.compute = list(dic = TRUE, waic = TRUE)
    )

    message("Fitting positive model")
    dfp <- df[species > 0]
    mp <- NULL
    if (nrow(dfp) > 0) {
      mp <- inla(
        species ~ chm + f(spatial_id, model = "besag", graph = g),
        data = dfp, family = "gamma",
        control.compute = list(dic = TRUE, waic = TRUE)
      )
    }

    results[[m]] <- list(binary_model = mb, positive_model = mp)
  }

  # Full Model with all CHM metrics (outside loop)
  message("Fitting full model with all CHM metrics")
  full_stk <- rast(chm_metrics)
  full_stk <- c(full_stk, ras_bin, ras)
  names(full_stk) <- c(names(chm_metrics), "species_binary", "species")

  full_vals <- terra::values(full_stk, dataframe = TRUE, na.rm = TRUE)
  full_df <- as.data.table(full_vals)

  chm_formula <- paste(names(chm_metrics), collapse = " + ")

  mb_full <- inla(
    as.formula(paste("species_binary ~", chm_formula)),
    data = full_df, 
    family = "binomial",
    control.compute = list(dic = TRUE, waic = TRUE)
  )

  dfp_full <- full_df[species > 0]
  mp_full <- NULL
  if (nrow(dfp_full) > 0) {
    mp_full <- inla(
      as.formula(paste("species ~", chm_formula)),
      data = dfp_full, 
      family = "gamma",
      control.compute = list(dic = TRUE, waic = TRUE)
    )
  }

  results$full_model <- list(binary_model_full = mb_full, positive_model_full = mp_full)

  return(results)
}

```

Hier kan je het model eindelijk runnen. Dit is echter het zwaarste stuk van heel het project. Doe dit dus niet zomaar! Om tijd te besparen kan je de test data (alternatieve species_folder) gebruiken. Hier gebruik je dan een suset van de data.

Merk op: full model runt twee keer per soort, mar heb nu even geen zin om die onnodige computerkracht te fiksen.

```{r process_all, message=TRUE, warning=TRUE}
# Apply analyze_species across all TIFF files
chm_metrics <- chm_metrics_5 #kies 5 (m) of 25  (m) resolutie

process_all_species <- function(dir, chm_metrics) {
  all <- list.files(dir, full.names = TRUE)
  tif <- all[endsWith(all, "_combined.tif")]
  out <- list()
  for (f in tif) {
    print(rast(f))
    out[[basename(f)]] <- analyze_species_5(f, chm_metrics)#kies opnieuw 5 (m) of 25  (m) resolutie
  }
  return(out)
}

# Run modeling
species_folder <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/R/aandachtsoorten/"
#species_folder <- "C:/Users/yolan/OneDrive/Documenten/UGENT/Master/Stage/R/aandachtsoorten_test/"
all_results <- process_all_species(species_folder, chm_metrics)
```
```{r}

tmp_lookup <- tempfile(fileext = ".xlsx")

# download the Google Sheet as xlsx
drive_download(
  as_id("1-hlCyqBvBbhOLiPWDGNZPa20i8dRq0yr"),  # your sheet’s file ID
  path      = tmp_lookup,
  type      = "xlsx",
  overwrite = TRUE
)

# read the “soorten” sheet (you can also use sheet = 2 if you prefer index)
lookup_table <- read_excel(tmp_lookup, sheet = "Soorten")
# 2. Prepare the lookup map: names = CODE, values = NEDERLANDSENAAMLEN
name_map <- setNames(lookup_table$NEDERLANDSENAAMLEN,
                     lookup_table$CODE)

# 3. Clean and remap all_results names
#    a) strip “_combined.tif”
clean_sp <- sub("_combined\\.tif$", "", names(all_results))

#    b) map to Dutch names when CODE matches, otherwise keep cleaned code
new_sp <- ifelse(
  clean_sp %in% names(name_map),
  name_map[clean_sp],
  clean_sp
)

# 4. Assign the new names back
names(all_results) <- new_sp
species_names <- names(all_results)
```




## Visualization of positive data
```{r run_all}
library(dplyr)
library(ggplot2)
library(tibble)

# Function to plot and save the gamma model
plot_gamma_model <- function(sp, mn, model, plot_dir) {
  cat("✅ Plotting model for:", sp, mn, "\n")
  
  # Extract model coefficients
  b0   <- model$summary.fixed["(Intercept)", "mean"]
  b1   <- model$summary.fixed[2, "mean"]
  prec <- model$summary.hyperpar[1, "mean"]
  
  # Create prediction grid
  grid <- seq(0, 10, length.out = 100)
  linp <- b0 + b1 * grid
  mp   <- exp(linp)
  lo   <- qgamma(0.05, shape = prec, scale = mp / prec)
  hi   <- qgamma(0.95, shape = prec, scale = mp / prec)
  pd   <- tibble(x = grid, fit = mp, lower = lo, upper = hi)
  
  # p-value for slope
  est <- b1
  se  <- model$summary.fixed[2, "sd"]
  pval <- 2 * (1 - pnorm(abs(est / se)))
  
  cat("✅ Model coefficients: Intercept =", b0,
      "| Slope =", b1,
      "| Precision =", prec, "\n")
  cat("✅ Plotting model with p-value:",
      format.pval(pval, digits = 3), "for", sp, mn, "\n")
  
  # Build the ggplot, including species name in the title
  p2 <- ggplot(pd, aes(x = x, y = fit)) +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    geom_line() +
    labs(
      title    = paste0("Species: ", sp),
      subtitle = paste0("Model: ", mn, " (p = ", format.pval(pval, digits = 2), ")"),
      x        = "Predictor (Grid)",
      y        = "Abundance"
    ) +
    theme_minimal()
  
  # Save the plot
  output_path <- file.path(plot_dir, paste0(sp, "_", mn, "_gamma.png"))
  cat("✅ Saving plot at:", output_path, "\n")
  
  tryCatch({
    ggsave(output_path, p2, width = 8, height = 6, dpi = 300)
    cat("✅ Plot saved successfully\n")
  }, error = function(e) {
    cat("❌ Error saving plot:", e$message, "\n")
  })
}

# Main Loop: Processing all species and all models
for (sp in names(all_results)) {
  res <- all_results[[sp]]  # res is a list of models per metric
  
  cat("\nProcessing species:", sp, "\n")
  
  for (mn in names(res)) {
    mr <- res[[mn]]
    
    # Skip if no positive model
    if (is.null(mr$positive_model)) {
      cat("❌ Skipping", mn, "- No positive model\n")
      next
    }
    
    cat("✅ Processing model:", mn, "\n")
    
    # Extract the model
    model <- mr$positive_model
    
    # Plot and save
    plot_gamma_model(sp, mn, model, plot_dir)
  }
}



```

```{r}
  saveRDS(
    res,
    file = file.path(plot_dir, paste0(sp, "_all_metrics_res.rds"))
  )
```
Results of binary data. 
```{r}
library(dplyr)
library(tibble)
library(purrr)
library(knitr)

binary_sig_summary_all <- 
  # 1) iterate over your species_names vector
  map_dfr(species_names, function(sp) {
    # 2) get that species’ results
    res <- all_results[[sp]]
    if (is.null(res)) return(NULL)
    
    # 3) for each metric in that species
    imap_dfr(res, function(mr, mn) {
      bm <- mr$binary_model
      if (is.null(bm)) return(NULL)
      
      # 4) extract and tidy the fixed‐effects summary
      as.data.frame(bm$summary.fixed) %>%
        rownames_to_column("Predictor") %>%
        rename(
          mean    = mean,
          sd      = sd,
          lower90 = `0.025quant`,
          upper90 = `0.975quant`
        ) %>%
        mutate(
          Species = sp,
          Metric  = mn,
          # two‐sided p‐value
          p.value = 2 * (1 - pnorm(abs(mean / sd)))
        ) %>%
        select(Species, Metric, Predictor, mean, sd, p.value, lower90, upper90)
    })
  })

# 5) Print the results
if (nrow(binary_sig_summary_all) > 0) {
  kable(
    binary_sig_summary_all,
    caption = "Binary‐Model Fixed Effects (with p-values)"
  )
} else {
  cat("No binary‐model predictors found across any species.\n")
}


```

```{r}
df_results <- as.data.frame(binary_sig_summary_all)

# inspect
print(head(df_results))

csv_file <- file.path(plot_dir, "binary_sig_summary_all.csv")
write.csv2(df_results, csv_file, row.names = FALSE)
cat("Written:", csv_file, "\n")
```
Hier combineren we het logistische (binaire) model en het gaussiaanse model. We nemen als het ware de som van de twee modellen.


```{r}
library(dplyr)
library(purrr)
library(knitr)

# 0) Helper to extract summary.fixed as a named tibble:
get_fixed <- function(model) {
  as.data.frame(model$summary.fixed) %>%
    rownames_to_column("Predictor") %>%
    rename(
      mean = mean,
      sd   = sd
    ) %>%
    # drop intercept here so it never appears
    filter(Predictor != "(Intercept)")
}

# 1) Compute and store combined effects for each predictor
all_results <- map(all_results, function(res_sp) {
  map(res_sp, function(mr) {
    bm <- mr$binary_model
    gm <- mr$positive_model
    if (!is.null(bm) && !is.null(gm)) {
      fb <- get_fixed(bm)
      fg <- get_fixed(gm)
      # inner join on Predictor to keep only those in both models
      fb %>%
        inner_join(fg, by = "Predictor", suffix = c(".bin", ".gam")) %>%
        transmute(
          Predictor,
          mean  = mean.bin + mean.gam,
          sd    = sqrt(sd.bin^2 + sd.gam^2),
          pval  = 2 * (1 - pnorm(abs((mean.bin + mean.gam) / sd)))
        ) -> ce_tbl
      
      # store as list of lists
      mr$combined_effect <- ce_tbl
    }
    mr
  })
})

# 2) Build a long summary tibble
combined_summary <- map_dfr(
  names(all_results),
  function(sp) {
    map_dfr(
      names(all_results[[sp]]),
      function(mn) {
        ce <- all_results[[sp]][[mn]]$combined_effect
        if (is.null(ce) || nrow(ce) == 0) return(NULL)
        ce %>%
          mutate(Species = sp, Metric = mn) %>%
          select(Species, Metric, Predictor, mean, sd, pval)
      }
    )
  }
)

# 3) Print
if (nrow(combined_summary) > 0) {
  kable(
    combined_summary,
    caption = "Combined (Logistic+Positive) Effects per Predictor (Intercept Excluded)"
  )
} else {
  cat("No common predictors found in both models for any species/metric.\n")
}


```


```{r}
df_results <- as.data.frame(combined_summary)

# inspect
print(head(df_results))

csv_file <- file.path(plot_dir, "combined_summary_all.csv")
write.csv2(df_results, csv_file, row.names = FALSE)
cat("Written:", csv_file, "\n")
```

